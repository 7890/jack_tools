                                   libsndfile

   Libsndfile is a library designed to allow the reading and writing of many
   different sampled sound file formats (such as MS Windows WAV and the
   Apple/SGI AIFF format) through one standard library interface.

   During read and write operations, formats are seamlessly converted between
   the format the application program has requested or supplied and the
   file's data format. The application programmer can remain blissfully
   unaware of issues such as file endian-ness and data format. See Note 1 and
   Note 2.

   Every effort is made to keep these documents up-to-date, error free and
   unambiguous. However, since maintaining the documentation is the least fun
   part of working on libsndfile, these docs can and do fall behind the
   behaviour of library. If any errors, omissions or ambiguities are found,
   please notify me (erikd) at mega-nerd dot com.

   To supplement this reference documentation, there are simple example
   programs included in the source code tarball. The test suite which is also
   part of the source code tarball is also a good place to look for the
   correct usage of the library functions.

   Finally, if you think there is some feature missing from libsndfile, check
   that it isn't already implemented (and documented) here.

Synopsis

   The functions of libsndfile are defined as follows:

       #include <stdio.h>
       #include <sndfile.h>

       SNDFILE*    sf_open          (const char *path, int mode, SF_INFO *sfinfo) ;
       SNDFILE*    sf_open_fd       (int fd, int mode, SF_INFO *sfinfo, int close_desc) ;
       SNDFILE*    sf_open_virtual  (SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data) ;
       int         sf_format_check  (const SF_INFO *info) ;

       sf_count_t  sf_seek          (SNDFILE *sndfile, sf_count_t frames, int whence) ;

       int         sf_command       (SNDFILE *sndfile, int cmd, void *data, int datasize) ;

       int         sf_error         (SNDFILE *sndfile) ;
       const char* sf_strerror      (SNDFILE *sndfile) ;
       const char* sf_error_number  (int errnum) ;

       int         sf_perror        (SNDFILE *sndfile) ;
       int         sf_error_str     (SNDFILE *sndfile, char* str, size_t len) ;

       int         sf_close         (SNDFILE *sndfile) ;
       void        sf_write_sync    (SNDFILE *sndfile) ;

       sf_count_t  sf_read_short    (SNDFILE *sndfile, short *ptr, sf_count_t items) ;
       sf_count_t  sf_read_int      (SNDFILE *sndfile, int *ptr, sf_count_t items) ;
       sf_count_t  sf_read_float    (SNDFILE *sndfile, float *ptr, sf_count_t items) ;
       sf_count_t  sf_read_double   (SNDFILE *sndfile, double *ptr, sf_count_t items) ;

       sf_count_t  sf_readf_short   (SNDFILE *sndfile, short *ptr, sf_count_t frames) ;
       sf_count_t  sf_readf_int     (SNDFILE *sndfile, int *ptr, sf_count_t frames) ;
       sf_count_t  sf_readf_float   (SNDFILE *sndfile, float *ptr, sf_count_t frames) ;
       sf_count_t  sf_readf_double  (SNDFILE *sndfile, double *ptr, sf_count_t frames) ;

       sf_count_t  sf_write_short   (SNDFILE *sndfile, short *ptr, sf_count_t items) ;
       sf_count_t  sf_write_int     (SNDFILE *sndfile, int *ptr, sf_count_t items) ;
       sf_count_t  sf_write_float   (SNDFILE *sndfile, float *ptr, sf_count_t items) ;
       sf_count_t  sf_write_double  (SNDFILE *sndfile, double *ptr, sf_count_t items) ;

       sf_count_t  sf_writef_short  (SNDFILE *sndfile, short *ptr, sf_count_t frames) ;
       sf_count_t  sf_writef_int    (SNDFILE *sndfile, int *ptr, sf_count_t frames) ;
       sf_count_t  sf_writef_float  (SNDFILE *sndfile, float *ptr, sf_count_t frames) ;
       sf_count_t  sf_writef_double (SNDFILE *sndfile, double *ptr, sf_count_t frames) ;

       sf_count_t  sf_read_raw      (SNDFILE *sndfile, void *ptr, sf_count_t bytes) ;
       sf_count_t  sf_write_raw     (SNDFILE *sndfile, void *ptr, sf_count_t bytes) ;

       const char* sf_get_string    (SNDFILE *sndfile, int str_type) ;
       int         sf_set_string    (SNDFILE *sndfile, int str_type, const char* str) ;


   SNDFILE* is an anonymous pointer to data which is private to the library.

File Open Function

       SNDFILE*  sf_open    (const char *path, int mode, SF_INFO *sfinfo) ;

   The SF_INFO structure is for passing data between the calling function and
   the library when opening a file for reading or writing. It is defined in
   sndfile.h as follows:

       typedef struct
       {    sf_count_t  frames ;     /* Used to be called samples. */
            int         samplerate ;
            int         channels ;
            int         format ;
            int         sections ;
            int         seekable ;
        } SF_INFO ;

   The mode parameter for this function can be any one of the following three
   values:

       SFM_READ    - read only mode
       SFM_WRITE   - write only mode
       SFM_RDWR    - read/write mode

   When opening a file for read, the format field should be set to zero
   before calling sf_open(). The only exception to this is the case of RAW
   files where the caller has to set the samplerate, channels and format
   fields to valid values. All other fields of the structure are filled in by
   the library.

   When opening a file for write, the caller must fill in structure members
   samplerate, channels, and format.

   The format field in the above SF_INFO structure is made up of the bit-wise
   OR of a major format type (values between 0x10000 and 0x08000000), a minor
   format type (with values less than 0x10000) and an optional endian-ness
   value. The currently understood formats are listed in sndfile.h as follows
   and also include bitmasks for separating major and minor file types. Not
   all combinations of endian-ness and major and minor file types are valid.

       enum
       {   /* Major formats. */
           SF_FORMAT_WAV          = 0x010000,     /* Microsoft WAV format (little endian). */
           SF_FORMAT_AIFF         = 0x020000,     /* Apple/SGI AIFF format (big endian). */
           SF_FORMAT_AU           = 0x030000,     /* Sun/NeXT AU format (big endian). */
           SF_FORMAT_RAW          = 0x040000,     /* RAW PCM data. */
           SF_FORMAT_PAF          = 0x050000,     /* Ensoniq PARIS file format. */
           SF_FORMAT_SVX          = 0x060000,     /* Amiga IFF / SVX8 / SV16 format. */
           SF_FORMAT_NIST         = 0x070000,     /* Sphere NIST format. */
           SF_FORMAT_VOC          = 0x080000,     /* VOC files. */
           SF_FORMAT_IRCAM        = 0x0A0000,     /* Berkeley/IRCAM/CARL */
           SF_FORMAT_W64          = 0x0B0000,     /* Sonic Foundry's 64 bit RIFF/WAV */
           SF_FORMAT_MAT4         = 0x0C0000,     /* Matlab (tm) V4.2 / GNU Octave 2.0 */
           SF_FORMAT_MAT5         = 0x0D0000,     /* Matlab (tm) V5.0 / GNU Octave 2.1 */
           SF_FORMAT_PVF          = 0x0E0000,     /* Portable Voice Format */
           SF_FORMAT_XI           = 0x0F0000,     /* Fasttracker 2 Extended Instrument */
           SF_FORMAT_HTK          = 0x100000,     /* HMM Tool Kit format */
           SF_FORMAT_SDS          = 0x110000,     /* Midi Sample Dump Standard */
           SF_FORMAT_AVR          = 0x120000,     /* Audio Visual Research */
           SF_FORMAT_WAVEX        = 0x130000,     /* MS WAVE with WAVEFORMATEX */
           SF_FORMAT_SD2          = 0x160000,     /* Sound Designer 2 */
           SF_FORMAT_FLAC         = 0x170000,     /* FLAC lossless file format */
           SF_FORMAT_CAF          = 0x180000,     /* Core Audio File format */
           SF_FORMAT_WVE          = 0x190000,     /* Psion WVE format */
           SF_FORMAT_OGG          = 0x200000,     /* Xiph OGG container */
           SF_FORMAT_MPC2K        = 0x210000,     /* Akai MPC 2000 sampler */
           SF_FORMAT_RF64         = 0x220000,     /* RF64 WAV file */

           /* Subtypes from here on. */

           SF_FORMAT_PCM_S8       = 0x0001,       /* Signed 8 bit data */
           SF_FORMAT_PCM_16       = 0x0002,       /* Signed 16 bit data */
           SF_FORMAT_PCM_24       = 0x0003,       /* Signed 24 bit data */
           SF_FORMAT_PCM_32       = 0x0004,       /* Signed 32 bit data */

           SF_FORMAT_PCM_U8       = 0x0005,       /* Unsigned 8 bit data (WAV and RAW only) */

           SF_FORMAT_FLOAT        = 0x0006,       /* 32 bit float data */
           SF_FORMAT_DOUBLE       = 0x0007,       /* 64 bit float data */

           SF_FORMAT_ULAW         = 0x0010,       /* U-Law encoded. */
           SF_FORMAT_ALAW         = 0x0011,       /* A-Law encoded. */
           SF_FORMAT_IMA_ADPCM    = 0x0012,       /* IMA ADPCM. */
           SF_FORMAT_MS_ADPCM     = 0x0013,       /* Microsoft ADPCM. */

           SF_FORMAT_GSM610       = 0x0020,       /* GSM 6.10 encoding. */
           SF_FORMAT_VOX_ADPCM    = 0x0021,       /* Oki Dialogic ADPCM encoding. */

           SF_FORMAT_G721_32      = 0x0030,       /* 32kbs G721 ADPCM encoding. */
           SF_FORMAT_G723_24      = 0x0031,       /* 24kbs G723 ADPCM encoding. */
           SF_FORMAT_G723_40      = 0x0032,       /* 40kbs G723 ADPCM encoding. */

           SF_FORMAT_DWVW_12      = 0x0040,       /* 12 bit Delta Width Variable Word encoding. */
           SF_FORMAT_DWVW_16      = 0x0041,       /* 16 bit Delta Width Variable Word encoding. */
           SF_FORMAT_DWVW_24      = 0x0042,       /* 24 bit Delta Width Variable Word encoding. */
           SF_FORMAT_DWVW_N       = 0x0043,       /* N bit Delta Width Variable Word encoding. */

           SF_FORMAT_DPCM_8       = 0x0050,       /* 8 bit differential PCM (XI only) */
           SF_FORMAT_DPCM_16      = 0x0051,       /* 16 bit differential PCM (XI only) */

           SF_FORMAT_VORBIS       = 0x0060,       /* Xiph Vorbis encoding. */

           /* Endian-ness options. */

           SF_ENDIAN_FILE         = 0x00000000,   /* Default file endian-ness. */
           SF_ENDIAN_LITTLE       = 0x10000000,   /* Force little endian-ness. */
           SF_ENDIAN_BIG          = 0x20000000,   /* Force big endian-ness. */
           SF_ENDIAN_CPU          = 0x30000000,   /* Force CPU endian-ness. */

           SF_FORMAT_SUBMASK      = 0x0000FFFF,
           SF_FORMAT_TYPEMASK     = 0x0FFF0000,
           SF_FORMAT_ENDMASK      = 0x30000000
       } ;

   Every call to sf_open() should be matched with a call to sf_close() to
   free up memory allocated during the call to sf_open().

   On success, the sf_open function returns a non-NULL pointer which should
   be passed as the first parameter to all subsequent libsndfile calls
   dealing with that audio file. On fail, the sf_open function returns a NULL
   pointer. An explanation of the error can obtained by passing NULL to
   sf_strerror.

  File Descriptor Open

       SNDFILE*  sf_open_fd (int fd, int mode, SF_INFO *sfinfo, int close_desc) ;

   Note: On Microsoft Windows, this function does not work if the application
   and the libsndfile DLL are linked to different versions of the Microsoft C
   runtime DLL.

   The second open function takes a file descriptor of a file that has
   already been opened. Care should be taken to ensure that the mode of the
   file represented by the descriptor matches the mode argument. This
   function is useful in the following circumstances:

     * Opening temporary files securely (ie use the tmpfile() to return a
       FILE* pointer and then using fileno() to retrieve the file descriptor
       which is then passed to libsndfile).
     * Opening files with file names using OS specific character encodings
       and then passing the file descriptor to sf_open_fd().
     * Opening sound files embedded within larger files. More info.

   Every call to sf_open_fd() should be matched with a call to sf_close() to
   free up memory allocated during the call to sf_open().

   When sf_close() is called, the file descriptor is only closed if the
   close_desc parameter was TRUE when the sf_open_fd() function was called.

   On success, the sf_open_fd function returns a non-NULL pointer which
   should be passed as the first parameter to all subsequent libsndfile calls
   dealing with that audio file. On fail, the sf_open_fd function returns a
   NULL pointer.

  Virtual File Open Function

       SNDFILE*  sf_open_virtual (SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data) ;

   Opens a soundfile from a virtual file I/O context which is provided by the
   caller. This is usually used to interface libsndfile to a stream or buffer
   based system. Apart from the sfvirtual and the user_data parameters this
   function behaves like sf_open.

       typedef struct
       {    sf_vio_get_filelen  get_filelen ;
            sf_vio_seek         seek ;
            sf_vio_read         read ;
            sf_vio_write        write ;
            sf_vio_tell         tell ;
       } SF_VIRTUAL_IO ;

   Libsndfile calls the callbacks provided by the SF_VIRTUAL_IO structure
   when opening, reading and writing to the virtual file context. The
   user_data pointer is a user defined context which will be available in the
   callbacks.

       typedef sf_count_t  (*sf_vio_get_filelen) (void *user_data) ;
       typedef sf_count_t  (*sf_vio_seek)        (sf_count_t offset, int whence, void *user_data) ;
       typedef sf_count_t  (*sf_vio_read)        (void *ptr, sf_count_t count, void *user_data) ;
       typedef sf_count_t  (*sf_vio_write)       (const void *ptr, sf_count_t count, void *user_data) ;
       typedef sf_count_t  (*sf_vio_tell)        (void *user_data) ;

    sf_vio_get_filelen

       typedef sf_count_t  (*sf_vio_get_filelen) (void *user_data) ;

   The virtual file contex must return the length of the virtual file in
   bytes.

    sf_vio_seek

       typedef sf_count_t  (*sf_vio_seek)        (sf_count_t offset, int whence, void *user_data) ;

   The virtual file context must seek to offset using the seek mode provided
   by whence which is one of

       SEEK_CUR
       SEEK_SET
       SEEK_END

   The return value must contain the new offset in the file.

    sf_vio_read

       typedef sf_count_t  (*sf_vio_read)        (void *ptr, sf_count_t count, void *user_data) ;

   The virtual file context must copy ("read") "count" bytes into the buffer
   provided by ptr and return the count of actually copied bytes.

    sf_vio_write

       typedef sf_count_t  (*sf_vio_write)       (const void *ptr, sf_count_t count, void *user_data) ;

   The virtual file context must process "count" bytes stored in the buffer
   passed with ptr and return the count of actually processed bytes.

    sf_vio_tell

       typedef sf_count_t  (*sf_vio_tell)        (void *user_data) ;

   Return the current position of the virtual file context.

Format Check Function

       int  sf_format_check (const SF_INFO *info) ;

   This function allows the caller to check if a set of parameters in the
   SF_INFO struct is valid before calling sf_open (SFM_WRITE).

   sf_format_check returns TRUE if the parameters are valid and FALSE
   otherwise.

File Seek Functions

       sf_count_t  sf_seek  (SNDFILE *sndfile, sf_count_t frames, int whence) ;

   The file seek functions work much like lseek in unistd.h with the
   exception that the non-audio data is ignored and the seek only moves
   within the audio data section of the file. In addition, seeks are defined
   in number of (multichannel) frames. Therefore, a seek in a stereo file
   from the current position forward with an offset of 1 would skip forward
   by one sample of both channels.

   like lseek(), the whence parameter can be any one of the following three
   values:

       SEEK_SET  - The offset is set to the start of the audio data plus offset (multichannel) frames.
       SEEK_CUR  - The offset is set to its current location plus offset (multichannel) frames.
       SEEK_END  - The offset is set to the end of the data plus offset (multichannel) frames.

   Internally, libsndfile keeps track of the read and write locations using
   separate read and write pointers. If a file has been opened with a mode of
   SFM_RDWR, bitwise OR-ing the standard whence values above with either
   SFM_READ or SFM_WRITE allows the read and write pointers to be modified
   separately. If the SEEK_* values are used on their own, the read and write
   pointers are both modified.

   Note that the frames offset can be negative and in fact should be when
   SEEK_END is used for the whence parameter.

   sf_seek will return the offset in (multichannel) frames from the start of
   the audio data or -1 if an error occured (ie an attempt is made to seek
   beyond the start or end of the file).

Error Reporting Functions

       int         sf_error        (SNDFILE *sndfile) ;

   This function returns the current error number for the given SNDFILE. The
   error number may be one of the following:

         enum
         {   SF_ERR_NO_ERROR             = 0,
             SF_ERR_UNRECOGNISED_FORMAT  = 1,
             SF_ERR_SYSTEM               = 2,
             SF_ERR_MALFORMED_FILE       = 3,
             SF_ERR_UNSUPPORTED_ENCODING = 4
         } ;

   or any one of many other internal error values. Applications should only
   test the return value against error values defined in <sndfile.h> as the
   internal error values are subject to change at any time. For errors not in
   the above list, the function sf_error_number() can be used to convert it
   to an error string.

       const char* sf_strerror     (SNDFILE *sndfile) ;
       const char* sf_error_number (int errnum) ;

   The error functions sf_strerror() and sf_error_number() convert the
   library's internal error enumerations into text strings.

       int         sf_perror     (SNDFILE *sndfile) ;
       int         sf_error_str  (SNDFILE *sndfile, char* str, size_t len) ;

   The functions sf_perror() and sf_error_str() are deprecated and will be
   dropped from the library at some later date.

File Close Function

       int  sf_close  (SNDFILE *sndfile) ;

   The close function closes the file, deallocates its internal buffers and
   returns 0 on success or an error value otherwise.

Write Sync Function

       void  sf_write_sync  (SNDFILE *sndfile) ;

   If the file is opened SFM_WRITE or SFM_RDWR, call the operating system's
   function to force the writing of all file cache buffers to disk. If the
   file is opened SFM_READ no action is taken.

File Read Functions (Items)

       sf_count_t  sf_read_short   (SNDFILE *sndfile, short *ptr, sf_count_t items) ;
       sf_count_t  sf_read_int     (SNDFILE *sndfile, int *ptr, sf_count_t items) ;
       sf_count_t  sf_read_float   (SNDFILE *sndfile, float *ptr, sf_count_t items) ;
       sf_count_t  sf_read_double  (SNDFILE *sndfile, double *ptr, sf_count_t items) ;

   The file read items functions fill the array pointed to by ptr with the
   requested number of items. The items parameter must be an integer product
   of the number of channels or an error will occur.

   It is important to note that the data type used by the calling program and
   the data format of the file do not need to be the same. For instance, it
   is possible to open a 16 bit PCM encoded WAV file and read the data using
   sf_read_float(). The library seamlessly converts between the two formats
   on-the-fly. See Note 1.

   The sf_read_XXXX functions return the number of items read. Unless the end
   of the file was reached during the read, the return value should equal the
   number of items requested. Attempts to read beyond the end of the file
   will not result in an error but will cause the sf_read_XXXX functions to
   return less than the number of items requested or 0 if already at the end
   of the file.

File Read Functions (Frames)

       sf_count_t  sf_readf_short   (SNDFILE *sndfile, short *ptr, sf_count_t frames) ;
       sf_count_t  sf_readf_int     (SNDFILE *sndfile, int *ptr, sf_count_t frames) ;
       sf_count_t  sf_readf_float   (SNDFILE *sndfile, float *ptr, sf_count_t frames) ;
       sf_count_t  sf_readf_double  (SNDFILE *sndfile, double *ptr, sf_count_t frames) ;

   The file read frames functions fill the array pointed to by ptr with the
   requested number of frames of data. The array must be large enough to hold
   the product of frames and the number of channels.

   Care must be taken to ensure that there is enough space in the array
   pointed to by ptr, to take (frames * channels) number of items (shorts,
   ints, floats or doubles).

   The sf_readf_XXXX functions return the number of frames read. Unless the
   end of the file was reached during the read, the return value should equal
   the number of frames requested. Attempts to read beyond the end of the
   file will not result in an error but will cause the sf_readf_XXXX
   functions to return less than the number of frames requested or 0 if
   already at the end of the file.

File Write Functions (Items)

       sf_count_t  sf_write_short   (SNDFILE *sndfile, short *ptr, sf_count_t items) ;
       sf_count_t  sf_write_int     (SNDFILE *sndfile, int *ptr, sf_count_t items) ;
       sf_count_t  sf_write_float   (SNDFILE *sndfile, float *ptr, sf_count_t items) ;
       sf_count_t  sf_write_double  (SNDFILE *sndfile, double *ptr, sf_count_t items) ;

   The file write items functions write the data in the array pointed to by
   ptr to the file. The items parameter must be an integer product of the
   number of channels or an error will occur.

   It is important to note that the data type used by the calling program and
   the data format of the file do not need to be the same. For instance, it
   is possible to open a 16 bit PCM encoded WAV file and write the data using
   sf_write_float(). The library seamlessly converts between the two formats
   on-the-fly. See Note 1.

   The sf_write_XXXX functions return the number of items written (which
   should be the same as the items parameter).

File Write Functions (Frames)

       sf_count_t  sf_writef_short  (SNDFILE *sndfile, short *ptr, sf_count_t frames) ;
       sf_count_t  sf_writef_int    (SNDFILE *sndfile, int *ptr, sf_count_t frames) ;
       sf_count_t  sf_writef_float  (SNDFILE *sndfile, float *ptr, sf_count_t frames) ;
       sf_count_t  sf_writef_double (SNDFILE *sndfile, double *ptr, sf_count_t frames) ;

   The file write frames functions write the data in the array pointed to by
   ptr to the file. The array must be large enough to hold the product of
   frames and the number of channels.

   The sf_writef_XXXX functions return the number of frames written (which
   should be the same as the frames parameter).

Raw File Read and Write Functions

       sf_count_t  sf_read_raw     (SNDFILE *sndfile, void *ptr, sf_count_t bytes) ;
       sf_count_t  sf_write_raw    (SNDFILE *sndfile, void *ptr, sf_count_t bytes) ;

   Note: Unless you are writing an external decoder/encode that uses
   libsndfile to handle the file headers, you should not be using these
   functions.

   The raw read and write functions read raw audio data from the audio file
   (not to be confused with reading RAW header-less PCM files). The number of
   bytes read or written must always be an integer multiple of the number of
   channels multiplied by the number of bytes required to represent one
   sample from one channel.

   The raw read and write functions return the number of bytes read or
   written (which should be the same as the bytes parameter).

   Note : The result of using of both regular reads/writes and raw
   reads/writes on compressed file formats other than SF_FORMAT_ALAW and
   SF_FORMAT_ULAW is undefined.

   See also : SFC_RAW_NEEDS_ENDSWAP

Functions for Reading and Writing String Data

       const char* sf_get_string   (SNDFILE *sndfile, int str_type) ;
       int         sf_set_string   (SNDFILE *sndfile, int str_type, const char* str) ;

   These functions allow strings to be set on files opened for write and to
   be retrieved from files opened for read where supported by the given file
   type. The str_type parameter can be any one of the following string types:

           enum
           {   SF_STR_TITLE,
               SF_STR_COPYRIGHT,
               SF_STR_SOFTWARE,
               SF_STR_ARTIST,
               SF_STR_COMMENT,
               SF_STR_DATE,
               SF_STR_ALBUM,
               SF_STR_LICENSE,
               SF_STR_TRACKNUMBER,
               SF_STR_GENRE
           } ;

   The sf_get_string() function returns the specified string if it exists and
   a NULL pointer otherwise. In addition to the string ids above,
   SF_STR_FIRST (== SF_STR_TITLE) and SF_STR_LAST (always the same as the
   highest numbers string id) are also available to allow iteration over all
   the available string ids.

   The sf_set_string() function sets the string data. It returns zero on
   success and non-zero on error. The error code can be converted to a string
   using sf_error_number().

     ----------------------------------------------------------------------

Note 1

   When converting between integer PCM formats of differing size (ie using
   sf_read_int() to read a 16 bit PCM encoded WAV file) libsndfile obeys one
   simple rule:

   Whenever integer data is moved from one sized container to another sized
   container, the most significant bit in the source container will become
   the most significant bit in the destination container.

   When converting between integer data and floating point data, different
   rules apply. The default behaviour when reading floating point data
   (sf_read_float() or sf_read_double ()) from a file with integer data is
   normalisation. Regardless of whether data in the file is 8, 16, 24 or 32
   bit wide, the data will be read as floating point data in the range [-1.0,
   1.0]. Similarly, data in the range [-1.0, 1.0] will be written to an
   integer PCM file so that a data value of 1.0 will be the largest allowable
   integer for the given bit width. This normalisation can be turned on or
   off using the sf_command interface.

Note 2

   Reading a file containg floating point data (allowable with WAV, AIFF, AU
   and other file formats) using integer read methods (sf_read_short() or
   sf_read_int()) can produce unexpected results. For instance the data in
   the file may have a maximum absolute value < 1.0 which would mean that all
   sample values read from the file will be zero. In order to read these
   files correctly using integer read methods, it is recommended that you use
   the sf_command interface, a command of SFC_SET_SCALE_FLOAT_INT_READ and a
   parameter of SF_TRUE to force correct scaling.

     ----------------------------------------------------------------------

   The libsndfile home page is here.

   Version : 1.0.25
